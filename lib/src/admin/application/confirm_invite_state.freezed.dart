// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'confirm_invite_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$ConfirmInviteState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() inviteExpired,
    required TResult Function() userAlreadyRegistered,
    required TResult Function() newUser,
    required TResult Function(ConfirmInviteResponseStatus status) response,
    required TResult Function(Object error, StackTrace st) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? inviteExpired,
    TResult? Function()? userAlreadyRegistered,
    TResult? Function()? newUser,
    TResult? Function(ConfirmInviteResponseStatus status)? response,
    TResult? Function(Object error, StackTrace st)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? inviteExpired,
    TResult Function()? userAlreadyRegistered,
    TResult Function()? newUser,
    TResult Function(ConfirmInviteResponseStatus status)? response,
    TResult Function(Object error, StackTrace st)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConfirmInviteLoading value) loading,
    required TResult Function(InviteExpired value) inviteExpired,
    required TResult Function(UserAlreadyRegistered value)
        userAlreadyRegistered,
    required TResult Function(NewUser value) newUser,
    required TResult Function(ConfirmResponse value) response,
    required TResult Function(ConfirmInviteError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConfirmInviteLoading value)? loading,
    TResult? Function(InviteExpired value)? inviteExpired,
    TResult? Function(UserAlreadyRegistered value)? userAlreadyRegistered,
    TResult? Function(NewUser value)? newUser,
    TResult? Function(ConfirmResponse value)? response,
    TResult? Function(ConfirmInviteError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConfirmInviteLoading value)? loading,
    TResult Function(InviteExpired value)? inviteExpired,
    TResult Function(UserAlreadyRegistered value)? userAlreadyRegistered,
    TResult Function(NewUser value)? newUser,
    TResult Function(ConfirmResponse value)? response,
    TResult Function(ConfirmInviteError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ConfirmInviteStateCopyWith<$Res> {
  factory $ConfirmInviteStateCopyWith(
          ConfirmInviteState value, $Res Function(ConfirmInviteState) then) =
      _$ConfirmInviteStateCopyWithImpl<$Res, ConfirmInviteState>;
}

/// @nodoc
class _$ConfirmInviteStateCopyWithImpl<$Res, $Val extends ConfirmInviteState>
    implements $ConfirmInviteStateCopyWith<$Res> {
  _$ConfirmInviteStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ConfirmInviteLoadingImplCopyWith<$Res> {
  factory _$$ConfirmInviteLoadingImplCopyWith(_$ConfirmInviteLoadingImpl value,
          $Res Function(_$ConfirmInviteLoadingImpl) then) =
      __$$ConfirmInviteLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConfirmInviteLoadingImplCopyWithImpl<$Res>
    extends _$ConfirmInviteStateCopyWithImpl<$Res, _$ConfirmInviteLoadingImpl>
    implements _$$ConfirmInviteLoadingImplCopyWith<$Res> {
  __$$ConfirmInviteLoadingImplCopyWithImpl(_$ConfirmInviteLoadingImpl _value,
      $Res Function(_$ConfirmInviteLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ConfirmInviteLoadingImpl implements ConfirmInviteLoading {
  const _$ConfirmInviteLoadingImpl();

  @override
  String toString() {
    return 'ConfirmInviteState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConfirmInviteLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() inviteExpired,
    required TResult Function() userAlreadyRegistered,
    required TResult Function() newUser,
    required TResult Function(ConfirmInviteResponseStatus status) response,
    required TResult Function(Object error, StackTrace st) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? inviteExpired,
    TResult? Function()? userAlreadyRegistered,
    TResult? Function()? newUser,
    TResult? Function(ConfirmInviteResponseStatus status)? response,
    TResult? Function(Object error, StackTrace st)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? inviteExpired,
    TResult Function()? userAlreadyRegistered,
    TResult Function()? newUser,
    TResult Function(ConfirmInviteResponseStatus status)? response,
    TResult Function(Object error, StackTrace st)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConfirmInviteLoading value) loading,
    required TResult Function(InviteExpired value) inviteExpired,
    required TResult Function(UserAlreadyRegistered value)
        userAlreadyRegistered,
    required TResult Function(NewUser value) newUser,
    required TResult Function(ConfirmResponse value) response,
    required TResult Function(ConfirmInviteError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConfirmInviteLoading value)? loading,
    TResult? Function(InviteExpired value)? inviteExpired,
    TResult? Function(UserAlreadyRegistered value)? userAlreadyRegistered,
    TResult? Function(NewUser value)? newUser,
    TResult? Function(ConfirmResponse value)? response,
    TResult? Function(ConfirmInviteError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConfirmInviteLoading value)? loading,
    TResult Function(InviteExpired value)? inviteExpired,
    TResult Function(UserAlreadyRegistered value)? userAlreadyRegistered,
    TResult Function(NewUser value)? newUser,
    TResult Function(ConfirmResponse value)? response,
    TResult Function(ConfirmInviteError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class ConfirmInviteLoading implements ConfirmInviteState {
  const factory ConfirmInviteLoading() = _$ConfirmInviteLoadingImpl;
}

/// @nodoc
abstract class _$$InviteExpiredImplCopyWith<$Res> {
  factory _$$InviteExpiredImplCopyWith(
          _$InviteExpiredImpl value, $Res Function(_$InviteExpiredImpl) then) =
      __$$InviteExpiredImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InviteExpiredImplCopyWithImpl<$Res>
    extends _$ConfirmInviteStateCopyWithImpl<$Res, _$InviteExpiredImpl>
    implements _$$InviteExpiredImplCopyWith<$Res> {
  __$$InviteExpiredImplCopyWithImpl(
      _$InviteExpiredImpl _value, $Res Function(_$InviteExpiredImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InviteExpiredImpl implements InviteExpired {
  const _$InviteExpiredImpl();

  @override
  String toString() {
    return 'ConfirmInviteState.inviteExpired()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InviteExpiredImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() inviteExpired,
    required TResult Function() userAlreadyRegistered,
    required TResult Function() newUser,
    required TResult Function(ConfirmInviteResponseStatus status) response,
    required TResult Function(Object error, StackTrace st) error,
  }) {
    return inviteExpired();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? inviteExpired,
    TResult? Function()? userAlreadyRegistered,
    TResult? Function()? newUser,
    TResult? Function(ConfirmInviteResponseStatus status)? response,
    TResult? Function(Object error, StackTrace st)? error,
  }) {
    return inviteExpired?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? inviteExpired,
    TResult Function()? userAlreadyRegistered,
    TResult Function()? newUser,
    TResult Function(ConfirmInviteResponseStatus status)? response,
    TResult Function(Object error, StackTrace st)? error,
    required TResult orElse(),
  }) {
    if (inviteExpired != null) {
      return inviteExpired();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConfirmInviteLoading value) loading,
    required TResult Function(InviteExpired value) inviteExpired,
    required TResult Function(UserAlreadyRegistered value)
        userAlreadyRegistered,
    required TResult Function(NewUser value) newUser,
    required TResult Function(ConfirmResponse value) response,
    required TResult Function(ConfirmInviteError value) error,
  }) {
    return inviteExpired(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConfirmInviteLoading value)? loading,
    TResult? Function(InviteExpired value)? inviteExpired,
    TResult? Function(UserAlreadyRegistered value)? userAlreadyRegistered,
    TResult? Function(NewUser value)? newUser,
    TResult? Function(ConfirmResponse value)? response,
    TResult? Function(ConfirmInviteError value)? error,
  }) {
    return inviteExpired?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConfirmInviteLoading value)? loading,
    TResult Function(InviteExpired value)? inviteExpired,
    TResult Function(UserAlreadyRegistered value)? userAlreadyRegistered,
    TResult Function(NewUser value)? newUser,
    TResult Function(ConfirmResponse value)? response,
    TResult Function(ConfirmInviteError value)? error,
    required TResult orElse(),
  }) {
    if (inviteExpired != null) {
      return inviteExpired(this);
    }
    return orElse();
  }
}

abstract class InviteExpired implements ConfirmInviteState {
  const factory InviteExpired() = _$InviteExpiredImpl;
}

/// @nodoc
abstract class _$$UserAlreadyRegisteredImplCopyWith<$Res> {
  factory _$$UserAlreadyRegisteredImplCopyWith(
          _$UserAlreadyRegisteredImpl value,
          $Res Function(_$UserAlreadyRegisteredImpl) then) =
      __$$UserAlreadyRegisteredImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserAlreadyRegisteredImplCopyWithImpl<$Res>
    extends _$ConfirmInviteStateCopyWithImpl<$Res, _$UserAlreadyRegisteredImpl>
    implements _$$UserAlreadyRegisteredImplCopyWith<$Res> {
  __$$UserAlreadyRegisteredImplCopyWithImpl(_$UserAlreadyRegisteredImpl _value,
      $Res Function(_$UserAlreadyRegisteredImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UserAlreadyRegisteredImpl implements UserAlreadyRegistered {
  const _$UserAlreadyRegisteredImpl();

  @override
  String toString() {
    return 'ConfirmInviteState.userAlreadyRegistered()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserAlreadyRegisteredImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() inviteExpired,
    required TResult Function() userAlreadyRegistered,
    required TResult Function() newUser,
    required TResult Function(ConfirmInviteResponseStatus status) response,
    required TResult Function(Object error, StackTrace st) error,
  }) {
    return userAlreadyRegistered();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? inviteExpired,
    TResult? Function()? userAlreadyRegistered,
    TResult? Function()? newUser,
    TResult? Function(ConfirmInviteResponseStatus status)? response,
    TResult? Function(Object error, StackTrace st)? error,
  }) {
    return userAlreadyRegistered?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? inviteExpired,
    TResult Function()? userAlreadyRegistered,
    TResult Function()? newUser,
    TResult Function(ConfirmInviteResponseStatus status)? response,
    TResult Function(Object error, StackTrace st)? error,
    required TResult orElse(),
  }) {
    if (userAlreadyRegistered != null) {
      return userAlreadyRegistered();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConfirmInviteLoading value) loading,
    required TResult Function(InviteExpired value) inviteExpired,
    required TResult Function(UserAlreadyRegistered value)
        userAlreadyRegistered,
    required TResult Function(NewUser value) newUser,
    required TResult Function(ConfirmResponse value) response,
    required TResult Function(ConfirmInviteError value) error,
  }) {
    return userAlreadyRegistered(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConfirmInviteLoading value)? loading,
    TResult? Function(InviteExpired value)? inviteExpired,
    TResult? Function(UserAlreadyRegistered value)? userAlreadyRegistered,
    TResult? Function(NewUser value)? newUser,
    TResult? Function(ConfirmResponse value)? response,
    TResult? Function(ConfirmInviteError value)? error,
  }) {
    return userAlreadyRegistered?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConfirmInviteLoading value)? loading,
    TResult Function(InviteExpired value)? inviteExpired,
    TResult Function(UserAlreadyRegistered value)? userAlreadyRegistered,
    TResult Function(NewUser value)? newUser,
    TResult Function(ConfirmResponse value)? response,
    TResult Function(ConfirmInviteError value)? error,
    required TResult orElse(),
  }) {
    if (userAlreadyRegistered != null) {
      return userAlreadyRegistered(this);
    }
    return orElse();
  }
}

abstract class UserAlreadyRegistered implements ConfirmInviteState {
  const factory UserAlreadyRegistered() = _$UserAlreadyRegisteredImpl;
}

/// @nodoc
abstract class _$$NewUserImplCopyWith<$Res> {
  factory _$$NewUserImplCopyWith(
          _$NewUserImpl value, $Res Function(_$NewUserImpl) then) =
      __$$NewUserImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NewUserImplCopyWithImpl<$Res>
    extends _$ConfirmInviteStateCopyWithImpl<$Res, _$NewUserImpl>
    implements _$$NewUserImplCopyWith<$Res> {
  __$$NewUserImplCopyWithImpl(
      _$NewUserImpl _value, $Res Function(_$NewUserImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NewUserImpl implements NewUser {
  const _$NewUserImpl();

  @override
  String toString() {
    return 'ConfirmInviteState.newUser()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NewUserImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() inviteExpired,
    required TResult Function() userAlreadyRegistered,
    required TResult Function() newUser,
    required TResult Function(ConfirmInviteResponseStatus status) response,
    required TResult Function(Object error, StackTrace st) error,
  }) {
    return newUser();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? inviteExpired,
    TResult? Function()? userAlreadyRegistered,
    TResult? Function()? newUser,
    TResult? Function(ConfirmInviteResponseStatus status)? response,
    TResult? Function(Object error, StackTrace st)? error,
  }) {
    return newUser?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? inviteExpired,
    TResult Function()? userAlreadyRegistered,
    TResult Function()? newUser,
    TResult Function(ConfirmInviteResponseStatus status)? response,
    TResult Function(Object error, StackTrace st)? error,
    required TResult orElse(),
  }) {
    if (newUser != null) {
      return newUser();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConfirmInviteLoading value) loading,
    required TResult Function(InviteExpired value) inviteExpired,
    required TResult Function(UserAlreadyRegistered value)
        userAlreadyRegistered,
    required TResult Function(NewUser value) newUser,
    required TResult Function(ConfirmResponse value) response,
    required TResult Function(ConfirmInviteError value) error,
  }) {
    return newUser(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConfirmInviteLoading value)? loading,
    TResult? Function(InviteExpired value)? inviteExpired,
    TResult? Function(UserAlreadyRegistered value)? userAlreadyRegistered,
    TResult? Function(NewUser value)? newUser,
    TResult? Function(ConfirmResponse value)? response,
    TResult? Function(ConfirmInviteError value)? error,
  }) {
    return newUser?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConfirmInviteLoading value)? loading,
    TResult Function(InviteExpired value)? inviteExpired,
    TResult Function(UserAlreadyRegistered value)? userAlreadyRegistered,
    TResult Function(NewUser value)? newUser,
    TResult Function(ConfirmResponse value)? response,
    TResult Function(ConfirmInviteError value)? error,
    required TResult orElse(),
  }) {
    if (newUser != null) {
      return newUser(this);
    }
    return orElse();
  }
}

abstract class NewUser implements ConfirmInviteState {
  const factory NewUser() = _$NewUserImpl;
}

/// @nodoc
abstract class _$$ConfirmResponseImplCopyWith<$Res> {
  factory _$$ConfirmResponseImplCopyWith(_$ConfirmResponseImpl value,
          $Res Function(_$ConfirmResponseImpl) then) =
      __$$ConfirmResponseImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ConfirmInviteResponseStatus status});
}

/// @nodoc
class __$$ConfirmResponseImplCopyWithImpl<$Res>
    extends _$ConfirmInviteStateCopyWithImpl<$Res, _$ConfirmResponseImpl>
    implements _$$ConfirmResponseImplCopyWith<$Res> {
  __$$ConfirmResponseImplCopyWithImpl(
      _$ConfirmResponseImpl _value, $Res Function(_$ConfirmResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = null,
  }) {
    return _then(_$ConfirmResponseImpl(
      null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as ConfirmInviteResponseStatus,
    ));
  }
}

/// @nodoc

class _$ConfirmResponseImpl implements ConfirmResponse {
  const _$ConfirmResponseImpl(this.status);

  @override
  final ConfirmInviteResponseStatus status;

  @override
  String toString() {
    return 'ConfirmInviteState.response(status: $status)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConfirmResponseImpl &&
            (identical(other.status, status) || other.status == status));
  }

  @override
  int get hashCode => Object.hash(runtimeType, status);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ConfirmResponseImplCopyWith<_$ConfirmResponseImpl> get copyWith =>
      __$$ConfirmResponseImplCopyWithImpl<_$ConfirmResponseImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() inviteExpired,
    required TResult Function() userAlreadyRegistered,
    required TResult Function() newUser,
    required TResult Function(ConfirmInviteResponseStatus status) response,
    required TResult Function(Object error, StackTrace st) error,
  }) {
    return response(status);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? inviteExpired,
    TResult? Function()? userAlreadyRegistered,
    TResult? Function()? newUser,
    TResult? Function(ConfirmInviteResponseStatus status)? response,
    TResult? Function(Object error, StackTrace st)? error,
  }) {
    return response?.call(status);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? inviteExpired,
    TResult Function()? userAlreadyRegistered,
    TResult Function()? newUser,
    TResult Function(ConfirmInviteResponseStatus status)? response,
    TResult Function(Object error, StackTrace st)? error,
    required TResult orElse(),
  }) {
    if (response != null) {
      return response(status);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConfirmInviteLoading value) loading,
    required TResult Function(InviteExpired value) inviteExpired,
    required TResult Function(UserAlreadyRegistered value)
        userAlreadyRegistered,
    required TResult Function(NewUser value) newUser,
    required TResult Function(ConfirmResponse value) response,
    required TResult Function(ConfirmInviteError value) error,
  }) {
    return response(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConfirmInviteLoading value)? loading,
    TResult? Function(InviteExpired value)? inviteExpired,
    TResult? Function(UserAlreadyRegistered value)? userAlreadyRegistered,
    TResult? Function(NewUser value)? newUser,
    TResult? Function(ConfirmResponse value)? response,
    TResult? Function(ConfirmInviteError value)? error,
  }) {
    return response?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConfirmInviteLoading value)? loading,
    TResult Function(InviteExpired value)? inviteExpired,
    TResult Function(UserAlreadyRegistered value)? userAlreadyRegistered,
    TResult Function(NewUser value)? newUser,
    TResult Function(ConfirmResponse value)? response,
    TResult Function(ConfirmInviteError value)? error,
    required TResult orElse(),
  }) {
    if (response != null) {
      return response(this);
    }
    return orElse();
  }
}

abstract class ConfirmResponse implements ConfirmInviteState {
  const factory ConfirmResponse(final ConfirmInviteResponseStatus status) =
      _$ConfirmResponseImpl;

  ConfirmInviteResponseStatus get status;
  @JsonKey(ignore: true)
  _$$ConfirmResponseImplCopyWith<_$ConfirmResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ConfirmInviteErrorImplCopyWith<$Res> {
  factory _$$ConfirmInviteErrorImplCopyWith(_$ConfirmInviteErrorImpl value,
          $Res Function(_$ConfirmInviteErrorImpl) then) =
      __$$ConfirmInviteErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Object error, StackTrace st});
}

/// @nodoc
class __$$ConfirmInviteErrorImplCopyWithImpl<$Res>
    extends _$ConfirmInviteStateCopyWithImpl<$Res, _$ConfirmInviteErrorImpl>
    implements _$$ConfirmInviteErrorImplCopyWith<$Res> {
  __$$ConfirmInviteErrorImplCopyWithImpl(_$ConfirmInviteErrorImpl _value,
      $Res Function(_$ConfirmInviteErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
    Object? st = null,
  }) {
    return _then(_$ConfirmInviteErrorImpl(
      null == error ? _value.error : error,
      null == st
          ? _value.st
          : st // ignore: cast_nullable_to_non_nullable
              as StackTrace,
    ));
  }
}

/// @nodoc

class _$ConfirmInviteErrorImpl implements ConfirmInviteError {
  const _$ConfirmInviteErrorImpl(this.error, this.st);

  @override
  final Object error;
  @override
  final StackTrace st;

  @override
  String toString() {
    return 'ConfirmInviteState.error(error: $error, st: $st)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConfirmInviteErrorImpl &&
            const DeepCollectionEquality().equals(other.error, error) &&
            (identical(other.st, st) || other.st == st));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(error), st);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ConfirmInviteErrorImplCopyWith<_$ConfirmInviteErrorImpl> get copyWith =>
      __$$ConfirmInviteErrorImplCopyWithImpl<_$ConfirmInviteErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() inviteExpired,
    required TResult Function() userAlreadyRegistered,
    required TResult Function() newUser,
    required TResult Function(ConfirmInviteResponseStatus status) response,
    required TResult Function(Object error, StackTrace st) error,
  }) {
    return error(this.error, st);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? inviteExpired,
    TResult? Function()? userAlreadyRegistered,
    TResult? Function()? newUser,
    TResult? Function(ConfirmInviteResponseStatus status)? response,
    TResult? Function(Object error, StackTrace st)? error,
  }) {
    return error?.call(this.error, st);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? inviteExpired,
    TResult Function()? userAlreadyRegistered,
    TResult Function()? newUser,
    TResult Function(ConfirmInviteResponseStatus status)? response,
    TResult Function(Object error, StackTrace st)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error, st);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConfirmInviteLoading value) loading,
    required TResult Function(InviteExpired value) inviteExpired,
    required TResult Function(UserAlreadyRegistered value)
        userAlreadyRegistered,
    required TResult Function(NewUser value) newUser,
    required TResult Function(ConfirmResponse value) response,
    required TResult Function(ConfirmInviteError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConfirmInviteLoading value)? loading,
    TResult? Function(InviteExpired value)? inviteExpired,
    TResult? Function(UserAlreadyRegistered value)? userAlreadyRegistered,
    TResult? Function(NewUser value)? newUser,
    TResult? Function(ConfirmResponse value)? response,
    TResult? Function(ConfirmInviteError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConfirmInviteLoading value)? loading,
    TResult Function(InviteExpired value)? inviteExpired,
    TResult Function(UserAlreadyRegistered value)? userAlreadyRegistered,
    TResult Function(NewUser value)? newUser,
    TResult Function(ConfirmResponse value)? response,
    TResult Function(ConfirmInviteError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class ConfirmInviteError implements ConfirmInviteState {
  const factory ConfirmInviteError(final Object error, final StackTrace st) =
      _$ConfirmInviteErrorImpl;

  Object get error;
  StackTrace get st;
  @JsonKey(ignore: true)
  _$$ConfirmInviteErrorImplCopyWith<_$ConfirmInviteErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$InviteRequest {
  String get providerId => throw _privateConstructorUsedError;
  String? get userId => throw _privateConstructorUsedError;
  String get inviteId => throw _privateConstructorUsedError;
  String get providerName => throw _privateConstructorUsedError;
  String get secret => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $InviteRequestCopyWith<InviteRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InviteRequestCopyWith<$Res> {
  factory $InviteRequestCopyWith(
          InviteRequest value, $Res Function(InviteRequest) then) =
      _$InviteRequestCopyWithImpl<$Res, InviteRequest>;
  @useResult
  $Res call(
      {String providerId,
      String? userId,
      String inviteId,
      String providerName,
      String secret});
}

/// @nodoc
class _$InviteRequestCopyWithImpl<$Res, $Val extends InviteRequest>
    implements $InviteRequestCopyWith<$Res> {
  _$InviteRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? providerId = null,
    Object? userId = freezed,
    Object? inviteId = null,
    Object? providerName = null,
    Object? secret = null,
  }) {
    return _then(_value.copyWith(
      providerId: null == providerId
          ? _value.providerId
          : providerId // ignore: cast_nullable_to_non_nullable
              as String,
      userId: freezed == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      inviteId: null == inviteId
          ? _value.inviteId
          : inviteId // ignore: cast_nullable_to_non_nullable
              as String,
      providerName: null == providerName
          ? _value.providerName
          : providerName // ignore: cast_nullable_to_non_nullable
              as String,
      secret: null == secret
          ? _value.secret
          : secret // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$InviteRequestImplCopyWith<$Res>
    implements $InviteRequestCopyWith<$Res> {
  factory _$$InviteRequestImplCopyWith(
          _$InviteRequestImpl value, $Res Function(_$InviteRequestImpl) then) =
      __$$InviteRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String providerId,
      String? userId,
      String inviteId,
      String providerName,
      String secret});
}

/// @nodoc
class __$$InviteRequestImplCopyWithImpl<$Res>
    extends _$InviteRequestCopyWithImpl<$Res, _$InviteRequestImpl>
    implements _$$InviteRequestImplCopyWith<$Res> {
  __$$InviteRequestImplCopyWithImpl(
      _$InviteRequestImpl _value, $Res Function(_$InviteRequestImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? providerId = null,
    Object? userId = freezed,
    Object? inviteId = null,
    Object? providerName = null,
    Object? secret = null,
  }) {
    return _then(_$InviteRequestImpl(
      providerId: null == providerId
          ? _value.providerId
          : providerId // ignore: cast_nullable_to_non_nullable
              as String,
      userId: freezed == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String?,
      inviteId: null == inviteId
          ? _value.inviteId
          : inviteId // ignore: cast_nullable_to_non_nullable
              as String,
      providerName: null == providerName
          ? _value.providerName
          : providerName // ignore: cast_nullable_to_non_nullable
              as String,
      secret: null == secret
          ? _value.secret
          : secret // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$InviteRequestImpl implements _InviteRequest {
  const _$InviteRequestImpl(
      {required this.providerId,
      this.userId,
      required this.inviteId,
      required this.providerName,
      required this.secret});

  @override
  final String providerId;
  @override
  final String? userId;
  @override
  final String inviteId;
  @override
  final String providerName;
  @override
  final String secret;

  @override
  String toString() {
    return 'InviteRequest(providerId: $providerId, userId: $userId, inviteId: $inviteId, providerName: $providerName, secret: $secret)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InviteRequestImpl &&
            (identical(other.providerId, providerId) ||
                other.providerId == providerId) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.inviteId, inviteId) ||
                other.inviteId == inviteId) &&
            (identical(other.providerName, providerName) ||
                other.providerName == providerName) &&
            (identical(other.secret, secret) || other.secret == secret));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, providerId, userId, inviteId, providerName, secret);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InviteRequestImplCopyWith<_$InviteRequestImpl> get copyWith =>
      __$$InviteRequestImplCopyWithImpl<_$InviteRequestImpl>(this, _$identity);
}

abstract class _InviteRequest implements InviteRequest {
  const factory _InviteRequest(
      {required final String providerId,
      final String? userId,
      required final String inviteId,
      required final String providerName,
      required final String secret}) = _$InviteRequestImpl;

  @override
  String get providerId;
  @override
  String? get userId;
  @override
  String get inviteId;
  @override
  String get providerName;
  @override
  String get secret;
  @override
  @JsonKey(ignore: true)
  _$$InviteRequestImplCopyWith<_$InviteRequestImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
