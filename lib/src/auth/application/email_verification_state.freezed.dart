// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'email_verification_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$EmailVerificationState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() verified,
    required TResult Function() verifiedWithAnotherEmail,
    required TResult Function() userNotExist,
    required TResult Function() invalidData,
    required TResult Function() loading,
    required TResult Function(Object? error, StackTrace? st) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? verified,
    TResult? Function()? verifiedWithAnotherEmail,
    TResult? Function()? userNotExist,
    TResult? Function()? invalidData,
    TResult? Function()? loading,
    TResult? Function(Object? error, StackTrace? st)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? verified,
    TResult Function()? verifiedWithAnotherEmail,
    TResult Function()? userNotExist,
    TResult Function()? invalidData,
    TResult Function()? loading,
    TResult Function(Object? error, StackTrace? st)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmailVerificationInitial value) initial,
    required TResult Function(EmailVerificationVerified value) verified,
    required TResult Function(EmailVerificationVerifiedWithAnotherEmail value)
        verifiedWithAnotherEmail,
    required TResult Function(EmailVerificationUserNotExist value) userNotExist,
    required TResult Function(EmailVerificationInvalidData value) invalidData,
    required TResult Function(EmailVerificationLoading value) loading,
    required TResult Function(EmailVerificationError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmailVerificationInitial value)? initial,
    TResult? Function(EmailVerificationVerified value)? verified,
    TResult? Function(EmailVerificationVerifiedWithAnotherEmail value)?
        verifiedWithAnotherEmail,
    TResult? Function(EmailVerificationUserNotExist value)? userNotExist,
    TResult? Function(EmailVerificationInvalidData value)? invalidData,
    TResult? Function(EmailVerificationLoading value)? loading,
    TResult? Function(EmailVerificationError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmailVerificationInitial value)? initial,
    TResult Function(EmailVerificationVerified value)? verified,
    TResult Function(EmailVerificationVerifiedWithAnotherEmail value)?
        verifiedWithAnotherEmail,
    TResult Function(EmailVerificationUserNotExist value)? userNotExist,
    TResult Function(EmailVerificationInvalidData value)? invalidData,
    TResult Function(EmailVerificationLoading value)? loading,
    TResult Function(EmailVerificationError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmailVerificationStateCopyWith<$Res> {
  factory $EmailVerificationStateCopyWith(EmailVerificationState value,
          $Res Function(EmailVerificationState) then) =
      _$EmailVerificationStateCopyWithImpl<$Res, EmailVerificationState>;
}

/// @nodoc
class _$EmailVerificationStateCopyWithImpl<$Res,
        $Val extends EmailVerificationState>
    implements $EmailVerificationStateCopyWith<$Res> {
  _$EmailVerificationStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EmailVerificationInitialCopyWith<$Res> {
  factory _$$EmailVerificationInitialCopyWith(_$EmailVerificationInitial value,
          $Res Function(_$EmailVerificationInitial) then) =
      __$$EmailVerificationInitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EmailVerificationInitialCopyWithImpl<$Res>
    extends _$EmailVerificationStateCopyWithImpl<$Res,
        _$EmailVerificationInitial>
    implements _$$EmailVerificationInitialCopyWith<$Res> {
  __$$EmailVerificationInitialCopyWithImpl(_$EmailVerificationInitial _value,
      $Res Function(_$EmailVerificationInitial) _then)
      : super(_value, _then);
}

/// @nodoc

class _$EmailVerificationInitial implements EmailVerificationInitial {
  const _$EmailVerificationInitial();

  @override
  String toString() {
    return 'EmailVerificationState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmailVerificationInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() verified,
    required TResult Function() verifiedWithAnotherEmail,
    required TResult Function() userNotExist,
    required TResult Function() invalidData,
    required TResult Function() loading,
    required TResult Function(Object? error, StackTrace? st) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? verified,
    TResult? Function()? verifiedWithAnotherEmail,
    TResult? Function()? userNotExist,
    TResult? Function()? invalidData,
    TResult? Function()? loading,
    TResult? Function(Object? error, StackTrace? st)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? verified,
    TResult Function()? verifiedWithAnotherEmail,
    TResult Function()? userNotExist,
    TResult Function()? invalidData,
    TResult Function()? loading,
    TResult Function(Object? error, StackTrace? st)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmailVerificationInitial value) initial,
    required TResult Function(EmailVerificationVerified value) verified,
    required TResult Function(EmailVerificationVerifiedWithAnotherEmail value)
        verifiedWithAnotherEmail,
    required TResult Function(EmailVerificationUserNotExist value) userNotExist,
    required TResult Function(EmailVerificationInvalidData value) invalidData,
    required TResult Function(EmailVerificationLoading value) loading,
    required TResult Function(EmailVerificationError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmailVerificationInitial value)? initial,
    TResult? Function(EmailVerificationVerified value)? verified,
    TResult? Function(EmailVerificationVerifiedWithAnotherEmail value)?
        verifiedWithAnotherEmail,
    TResult? Function(EmailVerificationUserNotExist value)? userNotExist,
    TResult? Function(EmailVerificationInvalidData value)? invalidData,
    TResult? Function(EmailVerificationLoading value)? loading,
    TResult? Function(EmailVerificationError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmailVerificationInitial value)? initial,
    TResult Function(EmailVerificationVerified value)? verified,
    TResult Function(EmailVerificationVerifiedWithAnotherEmail value)?
        verifiedWithAnotherEmail,
    TResult Function(EmailVerificationUserNotExist value)? userNotExist,
    TResult Function(EmailVerificationInvalidData value)? invalidData,
    TResult Function(EmailVerificationLoading value)? loading,
    TResult Function(EmailVerificationError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class EmailVerificationInitial implements EmailVerificationState {
  const factory EmailVerificationInitial() = _$EmailVerificationInitial;
}

/// @nodoc
abstract class _$$EmailVerificationVerifiedCopyWith<$Res> {
  factory _$$EmailVerificationVerifiedCopyWith(
          _$EmailVerificationVerified value,
          $Res Function(_$EmailVerificationVerified) then) =
      __$$EmailVerificationVerifiedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EmailVerificationVerifiedCopyWithImpl<$Res>
    extends _$EmailVerificationStateCopyWithImpl<$Res,
        _$EmailVerificationVerified>
    implements _$$EmailVerificationVerifiedCopyWith<$Res> {
  __$$EmailVerificationVerifiedCopyWithImpl(_$EmailVerificationVerified _value,
      $Res Function(_$EmailVerificationVerified) _then)
      : super(_value, _then);
}

/// @nodoc

class _$EmailVerificationVerified implements EmailVerificationVerified {
  const _$EmailVerificationVerified();

  @override
  String toString() {
    return 'EmailVerificationState.verified()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmailVerificationVerified);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() verified,
    required TResult Function() verifiedWithAnotherEmail,
    required TResult Function() userNotExist,
    required TResult Function() invalidData,
    required TResult Function() loading,
    required TResult Function(Object? error, StackTrace? st) error,
  }) {
    return verified();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? verified,
    TResult? Function()? verifiedWithAnotherEmail,
    TResult? Function()? userNotExist,
    TResult? Function()? invalidData,
    TResult? Function()? loading,
    TResult? Function(Object? error, StackTrace? st)? error,
  }) {
    return verified?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? verified,
    TResult Function()? verifiedWithAnotherEmail,
    TResult Function()? userNotExist,
    TResult Function()? invalidData,
    TResult Function()? loading,
    TResult Function(Object? error, StackTrace? st)? error,
    required TResult orElse(),
  }) {
    if (verified != null) {
      return verified();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmailVerificationInitial value) initial,
    required TResult Function(EmailVerificationVerified value) verified,
    required TResult Function(EmailVerificationVerifiedWithAnotherEmail value)
        verifiedWithAnotherEmail,
    required TResult Function(EmailVerificationUserNotExist value) userNotExist,
    required TResult Function(EmailVerificationInvalidData value) invalidData,
    required TResult Function(EmailVerificationLoading value) loading,
    required TResult Function(EmailVerificationError value) error,
  }) {
    return verified(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmailVerificationInitial value)? initial,
    TResult? Function(EmailVerificationVerified value)? verified,
    TResult? Function(EmailVerificationVerifiedWithAnotherEmail value)?
        verifiedWithAnotherEmail,
    TResult? Function(EmailVerificationUserNotExist value)? userNotExist,
    TResult? Function(EmailVerificationInvalidData value)? invalidData,
    TResult? Function(EmailVerificationLoading value)? loading,
    TResult? Function(EmailVerificationError value)? error,
  }) {
    return verified?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmailVerificationInitial value)? initial,
    TResult Function(EmailVerificationVerified value)? verified,
    TResult Function(EmailVerificationVerifiedWithAnotherEmail value)?
        verifiedWithAnotherEmail,
    TResult Function(EmailVerificationUserNotExist value)? userNotExist,
    TResult Function(EmailVerificationInvalidData value)? invalidData,
    TResult Function(EmailVerificationLoading value)? loading,
    TResult Function(EmailVerificationError value)? error,
    required TResult orElse(),
  }) {
    if (verified != null) {
      return verified(this);
    }
    return orElse();
  }
}

abstract class EmailVerificationVerified implements EmailVerificationState {
  const factory EmailVerificationVerified() = _$EmailVerificationVerified;
}

/// @nodoc
abstract class _$$EmailVerificationVerifiedWithAnotherEmailCopyWith<$Res> {
  factory _$$EmailVerificationVerifiedWithAnotherEmailCopyWith(
          _$EmailVerificationVerifiedWithAnotherEmail value,
          $Res Function(_$EmailVerificationVerifiedWithAnotherEmail) then) =
      __$$EmailVerificationVerifiedWithAnotherEmailCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EmailVerificationVerifiedWithAnotherEmailCopyWithImpl<$Res>
    extends _$EmailVerificationStateCopyWithImpl<$Res,
        _$EmailVerificationVerifiedWithAnotherEmail>
    implements _$$EmailVerificationVerifiedWithAnotherEmailCopyWith<$Res> {
  __$$EmailVerificationVerifiedWithAnotherEmailCopyWithImpl(
      _$EmailVerificationVerifiedWithAnotherEmail _value,
      $Res Function(_$EmailVerificationVerifiedWithAnotherEmail) _then)
      : super(_value, _then);
}

/// @nodoc

class _$EmailVerificationVerifiedWithAnotherEmail
    implements EmailVerificationVerifiedWithAnotherEmail {
  const _$EmailVerificationVerifiedWithAnotherEmail();

  @override
  String toString() {
    return 'EmailVerificationState.verifiedWithAnotherEmail()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmailVerificationVerifiedWithAnotherEmail);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() verified,
    required TResult Function() verifiedWithAnotherEmail,
    required TResult Function() userNotExist,
    required TResult Function() invalidData,
    required TResult Function() loading,
    required TResult Function(Object? error, StackTrace? st) error,
  }) {
    return verifiedWithAnotherEmail();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? verified,
    TResult? Function()? verifiedWithAnotherEmail,
    TResult? Function()? userNotExist,
    TResult? Function()? invalidData,
    TResult? Function()? loading,
    TResult? Function(Object? error, StackTrace? st)? error,
  }) {
    return verifiedWithAnotherEmail?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? verified,
    TResult Function()? verifiedWithAnotherEmail,
    TResult Function()? userNotExist,
    TResult Function()? invalidData,
    TResult Function()? loading,
    TResult Function(Object? error, StackTrace? st)? error,
    required TResult orElse(),
  }) {
    if (verifiedWithAnotherEmail != null) {
      return verifiedWithAnotherEmail();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmailVerificationInitial value) initial,
    required TResult Function(EmailVerificationVerified value) verified,
    required TResult Function(EmailVerificationVerifiedWithAnotherEmail value)
        verifiedWithAnotherEmail,
    required TResult Function(EmailVerificationUserNotExist value) userNotExist,
    required TResult Function(EmailVerificationInvalidData value) invalidData,
    required TResult Function(EmailVerificationLoading value) loading,
    required TResult Function(EmailVerificationError value) error,
  }) {
    return verifiedWithAnotherEmail(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmailVerificationInitial value)? initial,
    TResult? Function(EmailVerificationVerified value)? verified,
    TResult? Function(EmailVerificationVerifiedWithAnotherEmail value)?
        verifiedWithAnotherEmail,
    TResult? Function(EmailVerificationUserNotExist value)? userNotExist,
    TResult? Function(EmailVerificationInvalidData value)? invalidData,
    TResult? Function(EmailVerificationLoading value)? loading,
    TResult? Function(EmailVerificationError value)? error,
  }) {
    return verifiedWithAnotherEmail?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmailVerificationInitial value)? initial,
    TResult Function(EmailVerificationVerified value)? verified,
    TResult Function(EmailVerificationVerifiedWithAnotherEmail value)?
        verifiedWithAnotherEmail,
    TResult Function(EmailVerificationUserNotExist value)? userNotExist,
    TResult Function(EmailVerificationInvalidData value)? invalidData,
    TResult Function(EmailVerificationLoading value)? loading,
    TResult Function(EmailVerificationError value)? error,
    required TResult orElse(),
  }) {
    if (verifiedWithAnotherEmail != null) {
      return verifiedWithAnotherEmail(this);
    }
    return orElse();
  }
}

abstract class EmailVerificationVerifiedWithAnotherEmail
    implements EmailVerificationState {
  const factory EmailVerificationVerifiedWithAnotherEmail() =
      _$EmailVerificationVerifiedWithAnotherEmail;
}

/// @nodoc
abstract class _$$EmailVerificationUserNotExistCopyWith<$Res> {
  factory _$$EmailVerificationUserNotExistCopyWith(
          _$EmailVerificationUserNotExist value,
          $Res Function(_$EmailVerificationUserNotExist) then) =
      __$$EmailVerificationUserNotExistCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EmailVerificationUserNotExistCopyWithImpl<$Res>
    extends _$EmailVerificationStateCopyWithImpl<$Res,
        _$EmailVerificationUserNotExist>
    implements _$$EmailVerificationUserNotExistCopyWith<$Res> {
  __$$EmailVerificationUserNotExistCopyWithImpl(
      _$EmailVerificationUserNotExist _value,
      $Res Function(_$EmailVerificationUserNotExist) _then)
      : super(_value, _then);
}

/// @nodoc

class _$EmailVerificationUserNotExist implements EmailVerificationUserNotExist {
  const _$EmailVerificationUserNotExist();

  @override
  String toString() {
    return 'EmailVerificationState.userNotExist()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmailVerificationUserNotExist);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() verified,
    required TResult Function() verifiedWithAnotherEmail,
    required TResult Function() userNotExist,
    required TResult Function() invalidData,
    required TResult Function() loading,
    required TResult Function(Object? error, StackTrace? st) error,
  }) {
    return userNotExist();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? verified,
    TResult? Function()? verifiedWithAnotherEmail,
    TResult? Function()? userNotExist,
    TResult? Function()? invalidData,
    TResult? Function()? loading,
    TResult? Function(Object? error, StackTrace? st)? error,
  }) {
    return userNotExist?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? verified,
    TResult Function()? verifiedWithAnotherEmail,
    TResult Function()? userNotExist,
    TResult Function()? invalidData,
    TResult Function()? loading,
    TResult Function(Object? error, StackTrace? st)? error,
    required TResult orElse(),
  }) {
    if (userNotExist != null) {
      return userNotExist();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmailVerificationInitial value) initial,
    required TResult Function(EmailVerificationVerified value) verified,
    required TResult Function(EmailVerificationVerifiedWithAnotherEmail value)
        verifiedWithAnotherEmail,
    required TResult Function(EmailVerificationUserNotExist value) userNotExist,
    required TResult Function(EmailVerificationInvalidData value) invalidData,
    required TResult Function(EmailVerificationLoading value) loading,
    required TResult Function(EmailVerificationError value) error,
  }) {
    return userNotExist(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmailVerificationInitial value)? initial,
    TResult? Function(EmailVerificationVerified value)? verified,
    TResult? Function(EmailVerificationVerifiedWithAnotherEmail value)?
        verifiedWithAnotherEmail,
    TResult? Function(EmailVerificationUserNotExist value)? userNotExist,
    TResult? Function(EmailVerificationInvalidData value)? invalidData,
    TResult? Function(EmailVerificationLoading value)? loading,
    TResult? Function(EmailVerificationError value)? error,
  }) {
    return userNotExist?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmailVerificationInitial value)? initial,
    TResult Function(EmailVerificationVerified value)? verified,
    TResult Function(EmailVerificationVerifiedWithAnotherEmail value)?
        verifiedWithAnotherEmail,
    TResult Function(EmailVerificationUserNotExist value)? userNotExist,
    TResult Function(EmailVerificationInvalidData value)? invalidData,
    TResult Function(EmailVerificationLoading value)? loading,
    TResult Function(EmailVerificationError value)? error,
    required TResult orElse(),
  }) {
    if (userNotExist != null) {
      return userNotExist(this);
    }
    return orElse();
  }
}

abstract class EmailVerificationUserNotExist implements EmailVerificationState {
  const factory EmailVerificationUserNotExist() =
      _$EmailVerificationUserNotExist;
}

/// @nodoc
abstract class _$$EmailVerificationInvalidDataCopyWith<$Res> {
  factory _$$EmailVerificationInvalidDataCopyWith(
          _$EmailVerificationInvalidData value,
          $Res Function(_$EmailVerificationInvalidData) then) =
      __$$EmailVerificationInvalidDataCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EmailVerificationInvalidDataCopyWithImpl<$Res>
    extends _$EmailVerificationStateCopyWithImpl<$Res,
        _$EmailVerificationInvalidData>
    implements _$$EmailVerificationInvalidDataCopyWith<$Res> {
  __$$EmailVerificationInvalidDataCopyWithImpl(
      _$EmailVerificationInvalidData _value,
      $Res Function(_$EmailVerificationInvalidData) _then)
      : super(_value, _then);
}

/// @nodoc

class _$EmailVerificationInvalidData implements EmailVerificationInvalidData {
  const _$EmailVerificationInvalidData();

  @override
  String toString() {
    return 'EmailVerificationState.invalidData()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmailVerificationInvalidData);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() verified,
    required TResult Function() verifiedWithAnotherEmail,
    required TResult Function() userNotExist,
    required TResult Function() invalidData,
    required TResult Function() loading,
    required TResult Function(Object? error, StackTrace? st) error,
  }) {
    return invalidData();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? verified,
    TResult? Function()? verifiedWithAnotherEmail,
    TResult? Function()? userNotExist,
    TResult? Function()? invalidData,
    TResult? Function()? loading,
    TResult? Function(Object? error, StackTrace? st)? error,
  }) {
    return invalidData?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? verified,
    TResult Function()? verifiedWithAnotherEmail,
    TResult Function()? userNotExist,
    TResult Function()? invalidData,
    TResult Function()? loading,
    TResult Function(Object? error, StackTrace? st)? error,
    required TResult orElse(),
  }) {
    if (invalidData != null) {
      return invalidData();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmailVerificationInitial value) initial,
    required TResult Function(EmailVerificationVerified value) verified,
    required TResult Function(EmailVerificationVerifiedWithAnotherEmail value)
        verifiedWithAnotherEmail,
    required TResult Function(EmailVerificationUserNotExist value) userNotExist,
    required TResult Function(EmailVerificationInvalidData value) invalidData,
    required TResult Function(EmailVerificationLoading value) loading,
    required TResult Function(EmailVerificationError value) error,
  }) {
    return invalidData(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmailVerificationInitial value)? initial,
    TResult? Function(EmailVerificationVerified value)? verified,
    TResult? Function(EmailVerificationVerifiedWithAnotherEmail value)?
        verifiedWithAnotherEmail,
    TResult? Function(EmailVerificationUserNotExist value)? userNotExist,
    TResult? Function(EmailVerificationInvalidData value)? invalidData,
    TResult? Function(EmailVerificationLoading value)? loading,
    TResult? Function(EmailVerificationError value)? error,
  }) {
    return invalidData?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmailVerificationInitial value)? initial,
    TResult Function(EmailVerificationVerified value)? verified,
    TResult Function(EmailVerificationVerifiedWithAnotherEmail value)?
        verifiedWithAnotherEmail,
    TResult Function(EmailVerificationUserNotExist value)? userNotExist,
    TResult Function(EmailVerificationInvalidData value)? invalidData,
    TResult Function(EmailVerificationLoading value)? loading,
    TResult Function(EmailVerificationError value)? error,
    required TResult orElse(),
  }) {
    if (invalidData != null) {
      return invalidData(this);
    }
    return orElse();
  }
}

abstract class EmailVerificationInvalidData implements EmailVerificationState {
  const factory EmailVerificationInvalidData() = _$EmailVerificationInvalidData;
}

/// @nodoc
abstract class _$$EmailVerificationLoadingCopyWith<$Res> {
  factory _$$EmailVerificationLoadingCopyWith(_$EmailVerificationLoading value,
          $Res Function(_$EmailVerificationLoading) then) =
      __$$EmailVerificationLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EmailVerificationLoadingCopyWithImpl<$Res>
    extends _$EmailVerificationStateCopyWithImpl<$Res,
        _$EmailVerificationLoading>
    implements _$$EmailVerificationLoadingCopyWith<$Res> {
  __$$EmailVerificationLoadingCopyWithImpl(_$EmailVerificationLoading _value,
      $Res Function(_$EmailVerificationLoading) _then)
      : super(_value, _then);
}

/// @nodoc

class _$EmailVerificationLoading implements EmailVerificationLoading {
  const _$EmailVerificationLoading();

  @override
  String toString() {
    return 'EmailVerificationState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmailVerificationLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() verified,
    required TResult Function() verifiedWithAnotherEmail,
    required TResult Function() userNotExist,
    required TResult Function() invalidData,
    required TResult Function() loading,
    required TResult Function(Object? error, StackTrace? st) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? verified,
    TResult? Function()? verifiedWithAnotherEmail,
    TResult? Function()? userNotExist,
    TResult? Function()? invalidData,
    TResult? Function()? loading,
    TResult? Function(Object? error, StackTrace? st)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? verified,
    TResult Function()? verifiedWithAnotherEmail,
    TResult Function()? userNotExist,
    TResult Function()? invalidData,
    TResult Function()? loading,
    TResult Function(Object? error, StackTrace? st)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmailVerificationInitial value) initial,
    required TResult Function(EmailVerificationVerified value) verified,
    required TResult Function(EmailVerificationVerifiedWithAnotherEmail value)
        verifiedWithAnotherEmail,
    required TResult Function(EmailVerificationUserNotExist value) userNotExist,
    required TResult Function(EmailVerificationInvalidData value) invalidData,
    required TResult Function(EmailVerificationLoading value) loading,
    required TResult Function(EmailVerificationError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmailVerificationInitial value)? initial,
    TResult? Function(EmailVerificationVerified value)? verified,
    TResult? Function(EmailVerificationVerifiedWithAnotherEmail value)?
        verifiedWithAnotherEmail,
    TResult? Function(EmailVerificationUserNotExist value)? userNotExist,
    TResult? Function(EmailVerificationInvalidData value)? invalidData,
    TResult? Function(EmailVerificationLoading value)? loading,
    TResult? Function(EmailVerificationError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmailVerificationInitial value)? initial,
    TResult Function(EmailVerificationVerified value)? verified,
    TResult Function(EmailVerificationVerifiedWithAnotherEmail value)?
        verifiedWithAnotherEmail,
    TResult Function(EmailVerificationUserNotExist value)? userNotExist,
    TResult Function(EmailVerificationInvalidData value)? invalidData,
    TResult Function(EmailVerificationLoading value)? loading,
    TResult Function(EmailVerificationError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class EmailVerificationLoading implements EmailVerificationState {
  const factory EmailVerificationLoading() = _$EmailVerificationLoading;
}

/// @nodoc
abstract class _$$EmailVerificationErrorCopyWith<$Res> {
  factory _$$EmailVerificationErrorCopyWith(_$EmailVerificationError value,
          $Res Function(_$EmailVerificationError) then) =
      __$$EmailVerificationErrorCopyWithImpl<$Res>;
  @useResult
  $Res call({Object? error, StackTrace? st});
}

/// @nodoc
class __$$EmailVerificationErrorCopyWithImpl<$Res>
    extends _$EmailVerificationStateCopyWithImpl<$Res, _$EmailVerificationError>
    implements _$$EmailVerificationErrorCopyWith<$Res> {
  __$$EmailVerificationErrorCopyWithImpl(_$EmailVerificationError _value,
      $Res Function(_$EmailVerificationError) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = freezed,
    Object? st = freezed,
  }) {
    return _then(_$EmailVerificationError(
      error: freezed == error ? _value.error : error,
      st: freezed == st
          ? _value.st
          : st // ignore: cast_nullable_to_non_nullable
              as StackTrace?,
    ));
  }
}

/// @nodoc

class _$EmailVerificationError implements EmailVerificationError {
  const _$EmailVerificationError({this.error, this.st});

  @override
  final Object? error;
  @override
  final StackTrace? st;

  @override
  String toString() {
    return 'EmailVerificationState.error(error: $error, st: $st)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmailVerificationError &&
            const DeepCollectionEquality().equals(other.error, error) &&
            (identical(other.st, st) || other.st == st));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(error), st);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmailVerificationErrorCopyWith<_$EmailVerificationError> get copyWith =>
      __$$EmailVerificationErrorCopyWithImpl<_$EmailVerificationError>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() verified,
    required TResult Function() verifiedWithAnotherEmail,
    required TResult Function() userNotExist,
    required TResult Function() invalidData,
    required TResult Function() loading,
    required TResult Function(Object? error, StackTrace? st) error,
  }) {
    return error(this.error, st);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? verified,
    TResult? Function()? verifiedWithAnotherEmail,
    TResult? Function()? userNotExist,
    TResult? Function()? invalidData,
    TResult? Function()? loading,
    TResult? Function(Object? error, StackTrace? st)? error,
  }) {
    return error?.call(this.error, st);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? verified,
    TResult Function()? verifiedWithAnotherEmail,
    TResult Function()? userNotExist,
    TResult Function()? invalidData,
    TResult Function()? loading,
    TResult Function(Object? error, StackTrace? st)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error, st);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmailVerificationInitial value) initial,
    required TResult Function(EmailVerificationVerified value) verified,
    required TResult Function(EmailVerificationVerifiedWithAnotherEmail value)
        verifiedWithAnotherEmail,
    required TResult Function(EmailVerificationUserNotExist value) userNotExist,
    required TResult Function(EmailVerificationInvalidData value) invalidData,
    required TResult Function(EmailVerificationLoading value) loading,
    required TResult Function(EmailVerificationError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EmailVerificationInitial value)? initial,
    TResult? Function(EmailVerificationVerified value)? verified,
    TResult? Function(EmailVerificationVerifiedWithAnotherEmail value)?
        verifiedWithAnotherEmail,
    TResult? Function(EmailVerificationUserNotExist value)? userNotExist,
    TResult? Function(EmailVerificationInvalidData value)? invalidData,
    TResult? Function(EmailVerificationLoading value)? loading,
    TResult? Function(EmailVerificationError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmailVerificationInitial value)? initial,
    TResult Function(EmailVerificationVerified value)? verified,
    TResult Function(EmailVerificationVerifiedWithAnotherEmail value)?
        verifiedWithAnotherEmail,
    TResult Function(EmailVerificationUserNotExist value)? userNotExist,
    TResult Function(EmailVerificationInvalidData value)? invalidData,
    TResult Function(EmailVerificationLoading value)? loading,
    TResult Function(EmailVerificationError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class EmailVerificationError implements EmailVerificationState {
  const factory EmailVerificationError(
      {final Object? error, final StackTrace? st}) = _$EmailVerificationError;

  Object? get error;
  StackTrace? get st;
  @JsonKey(ignore: true)
  _$$EmailVerificationErrorCopyWith<_$EmailVerificationError> get copyWith =>
      throw _privateConstructorUsedError;
}

EmailVerificationData _$EmailVerificationDataFromJson(
    Map<String, dynamic> json) {
  return _EmailVerificationData.fromJson(json);
}

/// @nodoc
mixin _$EmailVerificationData {
  String get secret => throw _privateConstructorUsedError;
  String get userId => throw _privateConstructorUsedError;
  String get providerId => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EmailVerificationDataCopyWith<EmailVerificationData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmailVerificationDataCopyWith<$Res> {
  factory $EmailVerificationDataCopyWith(EmailVerificationData value,
          $Res Function(EmailVerificationData) then) =
      _$EmailVerificationDataCopyWithImpl<$Res, EmailVerificationData>;
  @useResult
  $Res call({String secret, String userId, String providerId});
}

/// @nodoc
class _$EmailVerificationDataCopyWithImpl<$Res,
        $Val extends EmailVerificationData>
    implements $EmailVerificationDataCopyWith<$Res> {
  _$EmailVerificationDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? secret = null,
    Object? userId = null,
    Object? providerId = null,
  }) {
    return _then(_value.copyWith(
      secret: null == secret
          ? _value.secret
          : secret // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      providerId: null == providerId
          ? _value.providerId
          : providerId // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_EmailVerificationDataCopyWith<$Res>
    implements $EmailVerificationDataCopyWith<$Res> {
  factory _$$_EmailVerificationDataCopyWith(_$_EmailVerificationData value,
          $Res Function(_$_EmailVerificationData) then) =
      __$$_EmailVerificationDataCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String secret, String userId, String providerId});
}

/// @nodoc
class __$$_EmailVerificationDataCopyWithImpl<$Res>
    extends _$EmailVerificationDataCopyWithImpl<$Res, _$_EmailVerificationData>
    implements _$$_EmailVerificationDataCopyWith<$Res> {
  __$$_EmailVerificationDataCopyWithImpl(_$_EmailVerificationData _value,
      $Res Function(_$_EmailVerificationData) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? secret = null,
    Object? userId = null,
    Object? providerId = null,
  }) {
    return _then(_$_EmailVerificationData(
      secret: null == secret
          ? _value.secret
          : secret // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      providerId: null == providerId
          ? _value.providerId
          : providerId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_EmailVerificationData implements _EmailVerificationData {
  const _$_EmailVerificationData(
      {required this.secret, required this.userId, required this.providerId});

  factory _$_EmailVerificationData.fromJson(Map<String, dynamic> json) =>
      _$$_EmailVerificationDataFromJson(json);

  @override
  final String secret;
  @override
  final String userId;
  @override
  final String providerId;

  @override
  String toString() {
    return 'EmailVerificationData(secret: $secret, userId: $userId, providerId: $providerId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_EmailVerificationData &&
            (identical(other.secret, secret) || other.secret == secret) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.providerId, providerId) ||
                other.providerId == providerId));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, secret, userId, providerId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_EmailVerificationDataCopyWith<_$_EmailVerificationData> get copyWith =>
      __$$_EmailVerificationDataCopyWithImpl<_$_EmailVerificationData>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_EmailVerificationDataToJson(
      this,
    );
  }
}

abstract class _EmailVerificationData implements EmailVerificationData {
  const factory _EmailVerificationData(
      {required final String secret,
      required final String userId,
      required final String providerId}) = _$_EmailVerificationData;

  factory _EmailVerificationData.fromJson(Map<String, dynamic> json) =
      _$_EmailVerificationData.fromJson;

  @override
  String get secret;
  @override
  String get userId;
  @override
  String get providerId;
  @override
  @JsonKey(ignore: true)
  _$$_EmailVerificationDataCopyWith<_$_EmailVerificationData> get copyWith =>
      throw _privateConstructorUsedError;
}
